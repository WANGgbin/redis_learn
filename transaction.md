# 使用

在 redis 中，可以通过以下方式来开启一个事务。

```sh

MULTI # 开始一个事务

SET ..
...

EXEC # 提交事务
```
# 原理

服务器为每个 redis 客户端都维护了一个结构体，该结构体中维护了一个命令队列。

当客户端通过 `MULTI` 开启事务后，此后的所有命令都不会立即执行而是会进入到命令队列中。

当客户端执行了 `EXEC` 后，服务端原子执行命令队列中的所有命令，最后将所有命令的结果都返回给客户端。


# watch

客户端可以通过 `WATCH` 命令来监视某些 key 的变动，都被监视的 key 被修改后，则服务端拒绝执行事务。结合 watch 的事务执行流程为：

```sh

WATCH key1 key2

MULTI

SET key1 val1
...

EXEC
```

在 EXEC 的时候，如果 key1/key2 被其他客户端修改，则拒绝执行事务， EXEC 返回 nil。

那么 watch 的工作原理是什么呢？

实际上，每个数据库都会维护一个 watch 字典。字典的 key 是被 watch 的 key，字典的值是一个链表，链表中的每一个成员是监视该 key 的客户端。

当某个 key 被修改后，就会遍历链表中的每一个客户端，标记客户端为不可执行事务的状态。

当客户端通过 EXEC 执行事务的时候，如果发现客户端为不可执行事务的状态，则直接返回 nil。

# redis 事务的 ACID

A：符合原子性。事务中所有的命令都是原子执行的。但需要注意的是，redis 的事务并不支持回滚操作。主要是基于两点：1、回滚操作增加 redis 复杂度。 2、错误通常是由不正确的命令导致的。

C: 符合一致性

I：由于 redis 本身的单线程特性，事务的隔离级别是 串行

D: 持久化看 redis 服务端的配置。

  - 如果是 RDB 持久化模式，只在固定的时机才进行 RDB 持久化。不满足事务的持久化特性。
  - 如果是 AOF 持久化模式：
    - appendfsync == always：满足持久化特性
    - appendfsync == everysec: 会丢失 1s 的数据
    - appendfsync == no: 不满足持久化特性，丢失数据取决于操作系统