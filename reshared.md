描述 redis 重分片的流程。

# slot(槽)

我们知道单实例的存储能力是有上限的，因此在数据量较大的场景下，一般都是集群部署。那么数据应该如何分布呢？

我们能想到的就是对 key 求哈希，然后根据机器数量取模。但这种方式的问题在于跟机器数量强绑定，当机器数量发生变化的时候，就需要对集群中每个 key 重新计算哈希值，重新取模，然后迁移到正确的实例上，这涉及到大量数据的迁移，在数据迁移期间，影响服务的可用性。

我们知道解决上述问题的方法在于跟机器数量解绑，常见的方法有一致性哈希算法。

而 redis 采用了跟一致性哈希类似的思想，将 key 分成了 16384 个槽，将 key 跟 slot 绑定在一起，跟机器数量解绑。一个槽只能属于一个实例。

# 什么时候会重分片

当集群实例 mem 空间不够时，且无法垂直扩展的时候(我们优先考虑垂直扩展，简单，高效)，就需要考虑水平扩展，水平扩展说白了就是增加实例的意思。或者出现热数据导致某几个实例 mem/cpu 飙升的时候，也需要考虑水平扩展。

# 详细流程是什么

- 将机器添加到集群
- 明确将哪些槽转移到新的实例上
- 遍历原实例的每一个槽中的每一个 key
- 调用 `migrate` 命令完成 key 迁移 (key 迁移是原子性的，迁移成功后，源实例删除此 key)

# 重分片期间服务可用性

结论：服务可用。

在重分片期间，key 可能在源实例上，也可能在目标实例上。那么怎么访问呢？

首先访问源实例，如果在则成功返回。如果不在，则给客户端发送 `ASK` 重定向错误，该重定向中包括迁移目标实例的 ip/port。客户端收到该错误后，然后重定向到目标实例，继续访问。

如果一条请求涉及多个 key(相同的 hash tag)，那么访问流程又是什么样的呢？如果发生部分 key 在源实例的情况，服务端会给客户端发送 `TRYAGAIN` 错误。