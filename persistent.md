描述 redis 中的持久化。

# AOF

将所有 **写** 的命令追加写到一个文件中。但实际上，并不是每次都写入到磁盘中，这会导致低效率。而是先写入到 AOF 缓冲区中。在一轮事件处理完毕后，根据 `appendfsync` 的配置，决定不同的刷盘策略。

- always, 总是刷盘。
- everysec, 每 1s 刷盘。默认值，性能和数据安全的折中选择。
- no,  由操作系统决定合适刷盘。

- 优点

相比于 RDB， 丢失数据更少。丢失的数据取决于 `appendfsync` 的配置。

- 缺点

缺点在于，随着服务器的不断运行，AOF 文件可能会越来越大。redis 通过 **重写 AOF 文件** 的方式来缩小 AOF 文件。

## 重写 AOF 文件

- 什么时候重写

TODO

- 怎么重写

通过执行 `BGREWRITEAOF` 命令，启动子进程，子进程可以获取父进程地址空间的 copy。当然也可以直接在父进程中进行 AOF 重写，但这会阻塞用户请求的处理。

重写的原理是，创建一个新的 AOF 文件，然后遍历数据库中的所有 key/value，将每一对 key/value 转化为一条写命令(实际上，如果某个 value 比较大，可能会转化为多条命令) 并追加到新的 AOF 文件中。

那么在重写的过程中，如何记录增量的写操作呢？

父进程内部会维护一个 **AOF 重写缓冲区** ，当子进程开始重写 AOF 的时候，父进程会将写命令写入到缓冲区中。当子进程重写 AOF 完毕并给父进程发送信号后，父进程执行信号处理程序(**内核态执行信号处理程序，会暂时阻塞用户请求的处理**)，信号处理程序负责将缓冲区中新增的写命令追加到新的 AOF 文件中，并使用新文件原子替换旧文件。

# RDB

- 原理

RDB 是一个二进制文件，通过执行 `SAVE/BGSAVE` 命令将数据库内容持久化到 RDB 文件中。通常我们选择 BGSAVE 在子进程中进行 RDB 操作。

写入的流程是遍历数据库中的所有内容，按照一定的编码方式把 key/val 序列化到 RDB 文件中。

- 什么时候会触发 RDB

用户可以通过配置服务器 `save` 选项，让服务器自动执行 BGSAVE 命令。

eg:

save 300 10 # 300s 内进行了至少 10 次更新操作
save 60 10000 # 60s 内进行了至少 10000 次更新操作

- 缺点

RDB 内容不能总是跟内存数据保持一致。因此使用 RDB 持久化很可能会导致数据的丢失。
