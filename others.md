# 缓存未命中问题

## 缓存击穿

- 是什么

    缓存击穿指的是某个 **热key** 缓存失效，导致大量的请求打到 db，影响 db 可用性。注意，我们这里强调的是 热key，普通key 即使失效也不会产生什么问题。

- 怎么解决

    - key 续约，可以使用一个定时任务，在每个 热key 快过期的时候，刷新 key 的过期时间，从而保证 key 一致在缓存中。
    - 不设置 key 的过期时间。

## 缓存雪崩

- 是什么

    如果大量的 key 未命中缓存，则直接请求 db，影响 db 可用性。通常有两种情况会导致缓存雪崩的发生：

    - 大量 key 同时过期
    - 缓存服务不可用

- 怎么解决

    - 可以给 key 的过期时间加一个随机数，保证 key 不会同时过期
    - 缓存服务使用高可用架构，比如 哨兵模式/集群模式。如果即使高可用架构，缓存服务仍然不可用，可以进行服务降级，设计一种机制能够自动检测缓存服务的可用性(比如某一个时间段内访问缓存大量报错)，不可用的时候，服务降级，不再请求 db，可用的时候，服务恢复。

## 缓存穿透

- 是什么

    指的是访问不存在的数据，导致每次请求的时候，都会访问缓存/db。通常是一些恶意攻击导致。

- 怎么解决

    - 布隆过滤器

        布隆过滤器存在两个问题：
        - 误判

            某个 key 不合法，但是误判为合法。但这是少数情况，可以通过提高哈希的次数来进一步降低误判率。
        
        - 一致性问题

            当新增/删除合法的 key 时，需要同步更新布隆过滤器，否则有效 key 会被过滤。

        - 复杂度

            布隆过滤器提高了系统整体的复杂度。

    - db 不存在的数据，缓存对应的值设置为空

        如果访问 db 也访问不到该数据，我们就认为这个数据时不合法的，在缓存中缓存该 key，值设置为空，有效期为永久。不过需要注意一个问题，后续当 db 中插入新的数据的时候，需要同步更新缓存中的 key。这就是下面要介绍的缓存/db 一致性。

        如果这种 key 很多的话，会导致耗费大量内存，导致 OOM 的风险。

    - key 过滤

        根据具体的业务逻辑，对 key 进行过滤。

# 缓存与 db 一致性问题

这是一个在生产环境中会经常遇到的问题。

- 为什么会有一致性问题

    根本原因为：
    - 写 db 和 写 缓存两步操作时非原子性的。
    - 高并发

- 如何解决

    常见的解决办法有：
    - 先更新缓存再更新 db
    - 先更新 db 再更新缓存
    - 先删除缓存再更新 db

        - 读/写问题
        考虑以下执行流：
        - 写请求删除缓存
        - 读请求读取 db 数据，并更新到缓存
        - 写请求更新缓存

        此时，就会导致不一致的情况发生。

        解决该问题的常见方法时**缓存双删**：
        即写操作更新 db 之后，**间隔一定时间后**，再删除一次缓存。为什么一定要间隔一定时间呢？考虑以下执行流：
        - 写请求删除缓存
        - 读请求读取 db 数据
        - 写请求更新 db 并再次删除缓存
        - 读请求使用旧数据更新缓存

        所以，如果立即删除，还是会导致数据不一致的情况发生。此外，缓存双删不够优雅，间隔一定时间，**到底间隔多少时间合适呢？**


    - 先更新 db 再删除缓存

    在绝大多数情况下，此种方法没有问题。但是考虑下面执行流：
      - 读请求读取缓存，发现缓存过期，从 db 读取数据
      - 写请求更新 db，再删除缓存
      - 读请求将读取的旧数据更新到缓存

    这就可能导致 db 跟缓存的数据不一致。但以上发生的条件为：
      - 缓存中数据过期
      - 写缓存延迟 > 写db + 删除缓存

    这种条件还是比较苛刻的。

    在此种方案中，如果删除缓存失败了怎么办呢？
    如果删除缓存失败，就会导致db 跟缓存中的数据不一致，直到成功删除缓存/缓存过期。如果缓存的过期时间较长，数据不一致的影响就会越大。
    通常，我们会通过**重试**的方式来删除缓存。

# 重试操作

- 同步重试

    在程序中同步重试若干次。但是，这会影响程序的性能。

- 异步重试

    针对同步重试的性能问题，可以使用异步重试。比如异步线程/线程池重试。但是此种方式也有很大的问题，如果进程异常退出，则所有的上下文信息都会丢失。

- mq 重试队列

    针对异步重试的问题，我们可以考虑将 重试消息发送到 mq，这里推荐使用 rocketmq，因为 rocketmq 自带重试队列。当重试一定次数失败后，则写入死信队列，发送报警，手动处理。

- db 重试表

    还可以将重试消息写入一张重试表中，重试表需要记录一个重试次数的字段。然后开启一个定时任务，定时全表扫描，处理所有未成功的重试任务，当某个任务重试次数达到一定的上限后，发送报警，手动处理。

- 消费 db bin_log

    以上方式对业务都有一定的侵入性。还可以通过消费 db bin_log 的方式来删除缓存，当然删除失败后，可以使用上面的四种方式来重试。

